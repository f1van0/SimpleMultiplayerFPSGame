using Normal.Realtime;
using Normal.Realtime.Serialization;

namespace JoyWay.Game.Interactable
{
    [RealtimeModel(createMetaModel:true)]
    public partial class LiftModel
    {
        [RealtimeProperty(1, true, false)]
        private bool _isRaised;
        [RealtimeProperty(2, true, false)]
        private bool _isLifting;
    }
}

/* ----- Begin Normal Autogenerated Code ----- */
namespace JoyWay.Game.Interactable {
    public partial class LiftModel : RealtimeModel {
        public bool isRaised {
            get {
                return _isRaisedProperty.value;
            }
            set {
                if (_isRaisedProperty.value == value) return;
                _isRaisedProperty.value = value;
                InvalidateReliableLength();
            }
        }
        
        public bool isLifting {
            get {
                return _isLiftingProperty.value;
            }
            set {
                if (_isLiftingProperty.value == value) return;
                _isLiftingProperty.value = value;
                InvalidateReliableLength();
            }
        }
        
        public enum PropertyID : uint {
            IsRaised = 1,
            IsLifting = 2,
        }
        
        #region Properties
        
        private ReliableProperty<bool> _isRaisedProperty;
        
        private ReliableProperty<bool> _isLiftingProperty;
        
        #endregion
        
        public LiftModel() : base(new MetaModel()) {
            _isRaisedProperty = new ReliableProperty<bool>(1, _isRaised);
            _isLiftingProperty = new ReliableProperty<bool>(2, _isLifting);
        }
        
        protected override void OnParentReplaced(RealtimeModel previousParent, RealtimeModel currentParent) {
            _isRaisedProperty.UnsubscribeCallback();
            _isLiftingProperty.UnsubscribeCallback();
        }
        
        protected override int WriteLength(StreamContext context) {
            var length = MetaModelWriteLength(context);
            length += _isRaisedProperty.WriteLength(context);
            length += _isLiftingProperty.WriteLength(context);
            return length;
        }
        
        protected override void Write(WriteStream stream, StreamContext context) {
            WriteMetaModel(stream, context);
            
            var writes = false;
            writes |= _isRaisedProperty.Write(stream, context);
            writes |= _isLiftingProperty.Write(stream, context);
            if (writes) InvalidateContextLength(context);
        }
        
        protected override void Read(ReadStream stream, StreamContext context) {
            var anyPropertiesChanged = false;
            while (stream.ReadNextPropertyID(out uint propertyID)) {
                var changed = false;
                switch (propertyID) {
                    case MetaModel.ReservedPropertyID: {
                        ReadMetaModel(stream, context);
                        break;
                    }
                    case (uint) PropertyID.IsRaised: {
                        changed = _isRaisedProperty.Read(stream, context);
                        break;
                    }
                    case (uint) PropertyID.IsLifting: {
                        changed = _isLiftingProperty.Read(stream, context);
                        break;
                    }
                    default: {
                        stream.SkipProperty();
                        break;
                    }
                }
                anyPropertiesChanged |= changed;
            }
            if (anyPropertiesChanged) {
                UpdateBackingFields();
            }
        }
        
        private void UpdateBackingFields() {
            _isRaised = isRaised;
            _isLifting = isLifting;
        }
        
    }
}
/* ----- End Normal Autogenerated Code ----- */
